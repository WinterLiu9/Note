

# 索引基础

MySQL的索引是在存储引擎层实现的
## 索引的类型

1. B+Tree索引

- B+Tree索引有不同的**实现方式**，各有优劣。

	* MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储
	* MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行

- 可以使用B+Tree索引的类型
	* B+Tree索引适合于全键值、键值范围或键前缀查找(根据最左前缀的查找)
		**B+Tree索引的有效查询类型**：
		* 全值匹配
		* 匹配最左前缀
		* 匹配列前缀
		* 匹配范围值
		* 精确匹配某一列并范围匹配另一列
		* 只访问索引的查询
		* 如果orderby子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求
- B+Tree索引的一些**限制**
	* 如果不是从索引的最左列开始查找，则无法使用索引
	* 不能跳过索引中的列（比如说我查询第一列和第三列，则索引只能使用第一列）
	* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

# 索引的优点
- 索引大大减少了服务器需要扫描的数据量
- 索引帮助服务器避免排序和临时表
- 索引可以将随机I/O变为顺序I/O

# 高性能索引策略
## 独立的列

指索引列不能是表达式的一部分，也不能是函数的参数

## 前缀索引和索引选择性

* 索引很长的字符串，需要使用前缀索引，这样可以大大减少索引空间，从而提升索引效率。但是会降低索引的选择性。（BLOB，TEXT必须使用前缀索引）
* 索引的选择性是指，不重复的索引值和数据表记录总数的比值。
* MySQL无法使用前缀索引做 order by和 group by，也无法使用前缀索引做覆盖扫描。

## 多列索引

为每一个列创建单独的索引，或者按照错误的顺序创建多列索引，是错误的。

## 选择合适的索引列顺序

* 当不需要考虑排序和分组的时候，将选择性最高的列放到前面通常是很好的。这时索引的作用是优化where条件的查找
* 将选择性最高的列放在索引的最前列，在某些场景可能有帮助，但通常不如避免随机I/O和排序那么重要，考虑问题需要全面。

## 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。
数据行实际存放在索引的叶子页中，“聚簇”表示数据行和相邻的键值紧凑的存储在一起。

### 聚簇索引的优点

+ 可以把相关的数据保存在一起
+ 因为聚簇索引把索引和数据保存在同一个B+Tree中，所以数据访问更快
+ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值
+ 使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行的时候无须更新二级索引中这个“指针”

### 聚簇索引的缺点

+ 聚簇索引最大限度的提高了 I/O 密集型应用的提升，如果数据全部在内存中，则访问的顺序就没有那么重要了，聚簇索引的优势也就没了。
+ 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。如果不是，插入完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表
+ 更新聚簇索引的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置
+ 基于聚簇索引的表在插入新行或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。
	* 当行的主键值要求必须将这一行插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，这就是一项页分裂的操作。页分裂会导致占用更多的磁盘空间
+ 聚簇索引可能会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候
+ 二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
+ 二级索引访问需要两次索引查找，而不是一次
	* 二级索引叶子结点保存的不是指向行物理位置的指针，而是行的主键值
	* 存储引擎需要找到二级索引的叶子结点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行  

### 覆盖索引

如果一个索引包含所有需要查询的值，我们就称之为覆盖索引。

* 覆盖索引的优点：
  1. 索引条目通常远小于数据行的大小，如果只需要读取索引，MySQL就会极大地减少数据访问量。
  2. 因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机磁盘读取每一行的数据的 I/O 要少得多。
  3. 因为 InnoDB 的聚簇索引，覆盖索引可以避免回表查询。

当发起一个被索引覆盖的查询的时，在 explain 的 Extra 列可以看到 “Using index” 的信息。

###  使用索引扫描来排序

EXPLAIN 出来的列的 type 列的值为 “index” ，则说明MySQL使用了索引扫描来做排序。

MySQL使用索引来对结果做排序的一些限制：

1. 只有当索引列的顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时

 	2. 如果需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时
 	3. 其他查找型的限制(最左前缀优先等等)