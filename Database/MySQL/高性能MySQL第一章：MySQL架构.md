## MySQL逻辑架构
* **连接管理、授权认证与安全**
    每个客户端连接都会在服务器进程中拥有一个线程
    认证基于用户名、原始主机信息和密码
* **优化与执行**
MySQL 会解析查询，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序以及选择合适的索引等。
***
## 并发控制
* **并发控制的两个层面：**
    服务器层和存储引擎层
* **读写锁**
    读锁是共享的，相互不堵塞的
    写锁是排他的，一个写锁会堵塞其他读锁和写锁
* **锁粒度**
    表锁：最基本的锁策略，开销最小的策略，（一般是在服务器层实现）
    行锁：支持最大程度的并发处理，同时也带来了最大的锁开销，行级锁只在存储引擎实现
***
## 事务
事务就是一个原子性的 SQL 查询或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。
* **ACID**
    1. Atomicity 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对一个事务来说，不可能只执行其中的一部分操作。
    2. Consistency 一致性：数据库总是从一个一致性状态转换到另外一个一致性状态。
    3. Isolation 隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。
    4. Durability 持续性：一旦事务提交，其所做的修改就会永久保存到数据库中。
* **隔离级别**
    1. READ UNCOMMITTED (未提交读)
        * 在未提交读级别，事务中的修改，即使没有提交，对其他事务也是可见的
        * 事务可以读取未提交的数据，被称为脏读
    2. READ COMMITTED (提交读)
        * 提交读满足隔离性的定义。一个事务开始时，只能“看见”已经提交的事务所做的修改
        * 也称作不可重复读，一个事务内执行两次同样的查询，可能会得到不一样的结果
    3. REPEATABLE READ (可重复读)（是 MySQL 默认事务隔离级别）
        * 解决了脏读的问题，该级别保证了在同一个事务中多次读取同样记录的结果是一致的
        * 幻读：当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的时候就会产生幻行。多版本并发控制 MVCC 解决了幻读的问题
    4. SERIALIZABLE (可串行化)
        * 强制事务串行执行
* **死锁**
    死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
    InnoDB目前处理死锁的方法是将持有最少行级排他锁的事务进行回滚

* **事务日志**
    1. 可以帮助提高事务的效率
    2. 使用事务日志，存储引擎在修改表数据的时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。
    3. 事务日志采取的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序 I/O ,而不是像随机 I/O 需要在磁盘的多个地方移动磁头
    4. 事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘
* **MySQL中的事务**
    1. 自动提交：如果不显式的开始一个事务，则每个查询都会被当成一个事务执行操作
    2. 在事务中混合使用存储引擎：MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。
    3. 隐式和显式锁定：InnoDB 采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行 commit 或者 rollback 的时候才会释放，并且所有的锁是在同一时刻被释放。
***
## 多版本并发控制
* 可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免的加锁操作，因此开销更低。虽然实现的机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。
* MVCC 的实现，是通过保存数据在某个时间点上的快照实现的。
    * 事务快照是用来存储数据库的事务运行情况，用来做可见性判断
    * 一个事务快照的创建过程可以概括为：
        1. 查看当前所有的未提交并活跃的事务，存储在数组中
        2. 选取未提交并活跃的事务中最小的XID，记录在快照的xmin中
        3. 选取所有已提交事务中最大的XID，加1后记录在xmax中
    * 快照生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性
        1. repeatable read 级别, 事务在 begin/start transaction 之后的第一条 select 读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;
        2. read committed 级别, 事务中每条 select 语句都会创建一个快照(read view);

* InnoDB 的 MVCC，InnoDB存储引擎在数据库每行数据的后面添加了三个字段来实现的。一个字段保存了行的创建时间，一个保存了行的过期(删除)时间。存储并不是实际时间值，而是系统版本号。每开始一个事务，系统版本号都会自动递增。还有一个是回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。
    1. SELECT：
        * InnoDB只查找版本早于当前事务版本的数据行。这样可以确保事务读取的行要么是在事务开始前就已经存在的，要么是事务自身插入或修改过的
        * 行的删除版本号要么未定义，要么大于当前事务版本号。这可以确保事务读到的行，在事务开始之前未被删除
    2. INSERT
        InnoDB为新插入的每一行保存当前系统版本号作为行版本号
    3. DELETE
        InnoDB为删除的每一行保存当前系统版本号作为行删除标识
    4. UPDATE
        InnoDB为插入一行新数据，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识
* MVCC只在可重复读和提交读两个隔离级别下工作
    1. 未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行。
    2. SERIALIZABLE 则会对所有读取的行都加锁。
* Undo-log
    1. Undo log 是 InnoDB MVCC 事务特性的重要组成部分。当我们对记录做了变更操作时就会产生 undo记录，Undo 记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。
    2. Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。
    3. 大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo
    4. 另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log
        *  insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。
        *  update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。
***
## MySQL存储引擎
* InnoDB
    1. InnoDB的数据存储在表空间中，表空间是由InnoDB管理的黑盒子，由一系列的数据文件组成。InnoDB可以将每个表的数据和索引放在单独的文件中。
    2. InnoDB采用MVCC来支持高并发，默认的隔离级别是可重复读，并且通过间隙锁(next-key locking)策略防止幻读的出现。间隙锁是的InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入
    3. InnoDB表是基于聚簇索引来实现的，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列。因此若表上的索引较多的话，主键应当尽可能的小。
* MyISAM
    1. MySQL5.1及之前的版本，是默认存储引擎。MyISAM提供了大量的特性，包括全文索引，压缩，空间函数等
    2. MyISAM不支持事务和行级锁，并且崩溃后无法安全恢复
    3. 存储：MyISAM将表存储在两个文件中：数据文件和索引文件。表可以包括动态或静态行
    4. 特性
        * 加锁和并发：对整张表加锁；在表有读取查询的同时，也可以往表中插入新的记录，称为并发插入
        * 修复：check table mytable; repair table mytable
        * 索引：即使是BLOB和TEXT等长字段，基于前500个字符创建索引；支持全文索引，是一种基于分词创建的索引
        * 延迟更新索引键：在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘
    5. 压缩表：压缩表是不能修改的，可以极大的减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升查询性能。支持索引，索引也是只读的