---
title: TCP
date: {date}
tags: 计算机网络
categories: 计算机网络
---
## TCP连接

**TCP连接的组成**
    一台主机上的缓存、变量和与进程连接的套接字 ，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。

- **最大报文段长度**
  TCP可以从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(Maximum Segment Size)。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（Maximum Transmission Unit, MTU）来设置。

------

## TCP报文段结构

- 16比特的**源端口号**和**目的端口号**
- 16比特的**校验和**字段
- 32比特的**序号**字段和**确认号**字段
- 16比特的**接收窗口**字段
- 4比特**首部长度**字段
- 可选与变长的**选项**字段
- 6比特的**标志**字段，ACK，RST，SYN，FIN

1. **序号和确认号**

   TCP把数据看成一个无结构的、有序的字节流。序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上。**一个报文段的序号**因此是该报文段首字节的字节流编号。
   确认号：A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号。

   TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供**累计确认**。

   接收方保留失序的字节，并等待缺少的字节以填补该间隔。

2. **往返时间的估计与超时**

EstimatedRTT = (1-a)EstimatedRTT + a * SampleRTT   
            （a一般取0.125）SampleRTT的均值

DevRTT = (1-b) * DevRTT + b * | SampleRTT - EstimatedRTT| 
            （b一般取0.25）

TimeoutInterval = EstimatedRTT +　４ * DevRTT 
    （要求将超时间隔设为EstimatedRTT加上一定余量，当波动较大的时候，这个余量应该大一点）

## 可靠数据传输

**TCP发送方有3个与发送和重传有关的主要事件：**
       1. 从上层应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP
       2. 当报文段被传给IP时，TCP就启动该定时器。（将定时器想象为与最早的未被确认的报文段相关联的）
       3. 来自接收方的确认报文段(ACK)。TCP将ACK的值y与它的变量SendBase进行比较(SendBase是最早未被确认的字节的序号，因此SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号)。
           TCP采用累计确认，所以y确认了编号在y之前的所有字节都已经收到。

**TCP接收方产生ACK：**

1. 具有所期望序号的按序报文段到达。所有在期望序号以及以前的数据都已经被确认。
   - 延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK
2. 具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输。
   - 立即发送单个累积ACK，以确认两个按序报文段
3. 比期望序号大的失序报文段到达。检测出间隔 
   - 立即发送冗余ACK，指示下一个期待字节的序号
4. 能部分或者完全填充接收数据间隔的报文段到达
   - 倘若该报文段起始于间隔的低端，则立即发送ACK

- **超时间隔加倍**
  TCP重传时都会将下一次的时间间隔设为先前值的两倍，而不是用从EstimateRTT和DevRTT推算出的值。提供了一个形式受限的拥塞控制
- **快速重传**

超时触发重传存在的问题之一是超时周期可能相对较长，增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余 ACK 来较好的检测到丢包情况。

一旦收到3个冗余ACK，TCP 就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。

- **是回退N步还是选择重传**

TCP确认是累积的，正确接收但失序的报文段是不会被接收方逐个确认的。

TCP发送方仅需维持已发送过但未被确认的字节的最小序号(SendBase)和下一个要发送的字节的序号(NextSeqNum)

选择确认允许TCP接收方有选择的确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。

TCP的差错恢复机制也是最好被分类为GBN协议与SR协议的混合体。

## 流量控制

**流量控制**用以消除发送方使接收方缓存溢出的可能性。TCP通过让发送方维护一个称为**接受窗口**的变量来提供流量控制。

TCP发送方也可能因为IP网络的拥塞而被遏制，这种形式的发送方的控制被称为**拥塞控制**。

LastByteSent - LastByteAcked <= rwnd
rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]

LastByteSent - LastByteAcked <= rwnd
主机A发送到连接中但未被确认的数据量小于等于主机B的缓存允许接收的数据量。

## TCP 连接管理

- **三次握手** 
  1. 发送SYN(Synchronize Sequence Numbers)报文段(报文段的首部中的SYN标志位被置为1，此外客户会随机选择一个初始序号，放在序号字段中)。
  2. 服务器提取出TCP SYN报文段，向该客户发送允许连接报文段。SYNACK报文段：这个报文段首部包含3个重要信息：SYN置为1，确认号字段被置为client_isn +１，服务器自己的初始序号。
  3. 收到SYNACK报文段后，客户也要给该连接分配缓存和变量。 发送报文段，此TCP报文段的首部的确认字段的序号为server_isn + 1，SYN被置为0，可以携带客户到服务器的数据。服务器收到客户端的确认后，连接建立。
- **三次握手的原因** 

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。
- **四次挥手**
  1. 客户应用进程发送一个特殊的报文段，其首部的FIN(finish)标志位被置为1
  2. 服务器收到后回送一个ACK报文段，此时 TCP 属于半关闭状态，服务器能向客户端发送数据但是客户端不能向服务器发送数据。
  3. 当服务器不再需要连接时，服务器发送它自己的终止报文段，其首部的FIN标志位也被置为1
  4. 该客户对这个服务器的终止报文段进行确认。此时两台主机上用于该连接的所有资源都被释放了。
- **四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

- **TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器
设置的时间 2MSL。这么做有两个理由：
       1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
       2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

- **客户TCP经历的典型的TCP状态序列**

建立：

1. 客户 TCP 开始时处于 CLOSE 状态
2. 发送 SYN 报文段后，进入 SYN_SENT 状态。然后等待服务器 TCP 的对客户所发报文段进行确认且 SYN 比特置为 1 的一个报文段
3. 收到来自服务器的确认后，客户 TCP 进入 ESTABLISHED 状态。TCP 客户就能发送和接收包含有效荷载数据的TCP报文段了

拆除：

1. 客户 TCP 发送一个带有FIN比特被置为 1 的 TCP 报文段，并进入 FIN_WAIT_1 状态。客户 TCP 等待一个来自服务器的带有确认的 TCP 报文段。
2. 收到来自服务器的确认后，客户 TCP 进入 FIN_WAIT_2 状态。客户等待来自服务器的 FIN 比特被置为1的另一个报文段
3. 收到服务器的 FIN 比特被置为 1 的报文段后，客户 TCP 对服务器的报文段进行确认，然后进去 TIME_WAIT 状态。(假定 ACK 丢失，TIME_WAIT 状态使 TCP 客户重传最后的确认报文)

- **SYN洪泛攻击**

SYN cookie

* 服务器收到一个 SYN 报文段时，并不会立即生成一个半开连接，而是生成一个初始 TCP 序列号，该序列号是 SYN 报文段的源和目的 IP 地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数。这种精心制作的初试序列号被称为 cookie。服务器并不记忆该 cookie 或任何对应于 SYN 的其他状态信息。
* 如果客户合法，返回一个 ACK 报文段，这个合法的 ACK ，在确认字段中的值等于在 SYNACK 字段(此时为 cookie 的值)中的值 + 1 .

## 拥塞控制原理
* **拥塞网络的代价：**

1. 分组的到达速率接近链路容量时，分组经历巨大的排队时延。
2. 发送方必须执行重传以补偿因为缓存溢出而丢弃(丢失)的分组。
3. 发送方在遇到大时延时所进行的不必要的重传会引起路由器利用其链路带宽来转发不必要的副本。
4. 当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。
* **拥塞控制方法**：

1. 端到端拥塞控制：网络层没有为运输层拥塞控制提供显示支持，端系统通过对网络行为的观察(如分组丢失与时延)来推断之
2. 网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显示反馈信息。ATM可用比特率拥塞控制中，路由器显示的通知发送方它能在输出链路上支持的最大主机发送速率。
    * 网络辅助的拥塞控制有两种方式：
        * 直接网络反馈：由网络路由器发给发送方。（通常采用一种阻塞分组的形式）
        * 路由器标记或更新从发送方流向接受方的分组中的某个字段来指示拥塞的产生。（更为通用，但是要经过一个RTT）


## TCP拥塞控制
* **TCP发送方如何限制它向其连接发送流量的速率呢？**

TCP拥塞控制机制跟踪一个额外的变量，**拥塞窗口cwnd**

LastByteSent - LastByteAcked <=min｛cwnd,rwnd｝

通过限制了发送方中未被确认的数据量，间接的限制了发送方的发送速率。

* **TCP发送方如何感知它到目的地之间的路径上存在拥塞的呢？**

“丢包事件”：超时事件和收到三个冗余的ACK。

因为TCP使用确认来触发增大它的拥塞窗口长度，TCP被称做自计时的。

* **TCP发送方怎样确定它应当发送的速率呢？**

1. 一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。
2. 一个确认的报文段指示该网络正在向接受方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。
3. 带宽探测，除非出现丢包才减慢速率，不然会一直加快。

* **TCP拥塞控制算法**

* **慢启动**

1. 初始cwnd设置为一个MSS，当该确认到达时，TCP将以指数形式增大拥塞窗口。
2. 何时结束指数增长：        
    * 当出现由超时指示的丢包事件 TCP发送方将cwnd设置为1，并重新开始慢启动，并且将ssthresh(**慢启动阈值**)设置为cwnd/2。
    * 当cwnd到达或者超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式。
    * 当检测到3个冗余ACK，这时TCP将执行一种快速重传并进入快速恢复状态。

* **拥塞避免**

1. 每个RTT只将cwnd的值增加一个MSS，发送方无论何时到达一个新的确认，就将cwnd增加一个MSS字节。

* **快速重传**

1. 把ssthresh设置为cwnd的一半 
2. 把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3) 
3. 重新进入拥塞避免阶段。

* **快速恢复**

1. 收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。
2. 再收到重复的ACK时，拥塞窗口增加1。
3. 当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。